#!/usr/bin/env python3

import rospy
from geometry_msgs.msg import Twist
from turtlesim.msg import Pose
from nav_msgs.msg import Odometry
from sensor_msgs.msg import LaserScan
from tf.transformations import euler_from_quaternion, quaternion_from_euler
import numpy as np
import time
import math

class seguidor:
    def __init__(self):
        rospy.init_node("seguidorlidar", anonymous=False)
        self.pub1=rospy.Publisher('/seguidor1/cmd_vel', Twist, queue_size=10) #publica no controle de velocidade a ser controlado

        rospy.Subscriber('/seguidor1/odom', Odometry, self.update_ref) #visualiza a posição do veiculo a ser controlado

        #rospy.Subscriber('/odom1hz', Odometry, self.update_refMestre)#visualiza a posição do mestre
        rospy.Subscriber('/seguidor1/scan', LaserScan,self.update_lidar)#Atualiza o lidar do robo seguidor

        self.ref= Pose()
        self.refM= Pose()
        self.rate=rospy.Rate(10)
        
        self.scan=LaserScan()

        self.max_vel=0.20
        self.max_ang=2.84
        self.frame1=[]
        self.frame2=[]
        self.framedif=[]

        for i in range(0,360):
            self.frame1.append(0)
            self.framedif.append(0)
            self.frame2.append(0)

        self.i=0

    def update_ref(self, msg):
        orientacao_quart=msg.pose.pose.orientation
        orientacao_list=[orientacao_quart.x, orientacao_quart.y, orientacao_quart.z, orientacao_quart.w]
        (_,_,yaw)=euler_from_quaternion(orientacao_list)

        self.ref.x=msg.pose.pose.position.x
        self.ref.y=msg.pose.pose.position.y
        self.ref.theta=yaw

    def update_refMestre(self, msg):
        orientacao_quart=msg.pose.pose.orientation
        orientacao_list=[orientacao_quart.x, orientacao_quart.y, orientacao_quart.z, orientacao_quart.w]
        (_,_,yaw)=euler_from_quaternion(orientacao_list)

        self.refM.x=msg.pose.pose.position.x
        self.refM.y=msg.pose.pose.position.y
        self.refM.theta=yaw
    
    def ref_distance(self):
        return np.sqrt(  (self.refM.x - self.ref.x)**2 + (self.refM.y - self.ref.y)**2)
    

    def linear_vel_control(self, kp = 1.5):
        distance = self.ref_distance()
        control = kp* distance
        if abs(control) > self.max_vel:
            control = self.max_vel*np.sign(control)
        return control

    def angular_vel_control(self,  kp=6):
        angle_r = np.arctan2(self.refM.y - self.ref.y,  self.refM.x - self.ref.x )        
        control = kp*(angle_r - self.ref.theta)
        if abs(control) > self.max_ang:
            control = self.max_ang*np.sign(control)
        return control


    def run(self):
        ref_tol = 0.5
        vel_msg = Twist()
        while self.ref_distance() >= ref_tol:
            vel_msg.linear.x = self.linear_vel_control()
            vel_msg.linear.y = 0
            vel_msg.linear.z = 0
            vel_msg.angular.x = 0
            vel_msg.angular.y = 0
            vel_msg.angular.z = self.angular_vel_control()

            self.pub1.publish(vel_msg)

            self.rate.sleep()

        # stop
        vel_msg.linear.x = 0
        vel_msg.angular.z= 0
        self.pub1.publish(vel_msg)

        #rospy.loginfo("Ponto")
        #rospy.loginfo(self.ref.x)

    def update_lidar(self, msg):
        self.scan=msg
        dist=0
        angle=0
        rg=0
        if (self.i==3):
            self.i=self.i+1
            for i in range(0,360):
                    if(math.isinf(self.scan.ranges[i])):
                        self.frame2[i]= abs(3.5)
                    else:
                        self.frame2[i]= abs(self.scan.ranges[i])
 
            while (rg<360):
                self.framedif[rg]=abs(self.frame2[rg]-self.frame1[rg])
                if(self.framedif[rg]>0.2 and (self.framedif[rg]<dist or dist==0)and self.framedif[rg]<3):
                    # if(self.scan.ranges[rg]<dist):
                    dist=self.framedif[rg]
                    angle=rg

                rg=rg+1
            if (dist!= 0):        
                self.refM.x= self.ref.x+self.frame2[angle]*math.cos(self.ref.theta+math.radians(angle))
                self.refM.y= self.ref.y+self.frame2[angle]*math.sin(self.ref.theta+math.radians(angle))
            
        
            print(self.framedif)  
            print(dist)
            print(angle)             
            #self.refM.yaw=
        else:
            self.i=self.i+1
            if(self.i==20):
                self.i=0
                self.refM.x=self.ref.x
                self.refM.y=self.ref.y
            if(self.i==1):
                for i in range(0,360):
                    if(math.isinf(self.scan.ranges[i])):
                        self.frame1[i]= abs(3.5)
                    else:
                        self.frame1[i]= abs(self.scan.ranges[i])
                
                



if __name__ == '__main__':
    try :
        seg=seguidor()
        while not rospy.is_shutdown():
            seg.run()
            seg.rate.sleep()
            #rospy.get_pa
    except rospy.ROSInterruptException:
        pass
